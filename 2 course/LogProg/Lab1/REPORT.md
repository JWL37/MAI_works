# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Начкебия Р.Ш.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В первую очередь списки в Прологе отличаются тем,что у них нет ограничения на количества элементов в списках, нет ограничений на вложенность этих списков ([[],[],...,[]]),и нет ограничений на тип элементов(они могут быть любыми [#,2,fad]).В императивных языках програмирования зачастую для хранения данных используется массив,в котором есть ограничения и на тип данных которые мы храним(он должен быть только один),и на количество элементов.Стоит отметить,что мои слова,про "нет ограничений" несколько утрированы.Ограничения конечно же есть и это ограничение связаны с производительностью вашего компьютера(его ресурсы не бесконечны).Так же в масивах можно обращаться по индексу,когда в списках для получения доступа к определённому элементу нужно перебрать все элементы до него.Списки в прологе это рекурсивная структура. Каждый список состоит из head(головы)-это первый элемент списка и tail(хвоста)-весь оставшиийся список,кроме головы.tail-это тоже список,а следовательно у самого хвоста тоже есть голова и хвост(тут как раз можно увидеть рекурсию).Списки в прологе похожи на линейные односвязные списки,которые мы писали на 2 семестре.Отчасти списки в python тоже похожи на списки в прологе(произвольный тип элеметов,количество элементов не ограничено).

## Задание 1.1: Предикат обработки списка
Вариант задания №1-Получение последнего элемента списка.

`get_last_element(List,LastElem)` - Получение последнего элемента списка.
`get_last_element_with_std(List, LastElem).`-получение последнего элемента списка на основе стандартных предикатов.

Примеры использования:
```prolog
?- get_last_element([ade],LastElem).
LastElem = ade ;
false.

?- get_last_element([1,2,aasa,10],LastElem).
LastElem = 10 ;
false.

?- get_last_element_with_std([1,211,aaa],LastElem).
LastElem = aaa ;
false.
```

Реализация:
```prolog
get_last_element([LastElem], LastElem).
get_last_element([_|Tail], LastElem) :- get_last_element(Tail, LastElem).
```
Реализация со стандартными предикатами:
```prolog
get_last_element_with_std(List, LastElem) :-std_append(_, [LastElem], List).  
```
В случае `get_last_element(List,LastElem)` проходим рекурсивно до конца списка.В конце выполняется 1 правило и в переменную записывается последний элемент.
В предикате `get_last_element_with_std(List, LastElem).` я использую стандартный предикат `std_append(_, [LastElem], List.`.У него три аргумента : "Что коннкантенируем?"(нам  не важен сам список,кроме последнего элемента  ,поэтому используем `_`) , "С чем конкантенируем"(в нашем случае с последним элементом) и результат(наш списоск).Получается,если рассматривать только предикат std_append(...).,то у нас получаетя,что мы конкантенируем список какой-то длины с последним последним элементом LastElem и получается List.

Пример:
Допустип у нас есть большой список чисел,в котором мы не знаем значения элементов.Тогда при помощи предикатa get_last_element() и remove() можно сначала выяснить,что это за элемент,а потом в случае необходимости удалить и тогда у нас получится такая структура данных как стек,в котором мы добавляем и удаляем элементы в конце.

## Задание 1.2: Предикат обработки числового списка
Вариант задания №5-Вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей).
`scalar_mult_without_std` - Вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) без стандартных предикатов.

Примеры использования:
```prolog
?- scalar_mult_without_std([1,2],[2,3,4,5],Res).
Res = 8 ;
false.

?- scalar_mult_without_std([1,2],[2],Res).
Res = 2 ;
false.

?- scalar_mult_without_std([3,2],[2,3],Res).
Res = 12 ;
false.

?- scalar_mult([3,2,3,2,3],[2,3],Res).
Res = 12.
```

Реализация:
```prolog
scalar_mult_without_std([], [], 0).

scalar_mult_without_std([], [Elem_second_vector | Rest_part_vector_2], Result) :-
    scalar_mult_without_std([0], [Elem_second_vector | Rest_part_vector_2], Result).

scalar_mult_without_std([Elem_first_vector | Rest_part_vector_1], [], Result) :-
    scalar_mult_without_std([Elem_first_vector | Rest_part_vector_1], [0], Result).

scalar_mult_without_std([Elem_first_vector | Rest_part_vector_1], [Elem_second_vector | Rest_part_vector_2], Result) :-
    scalar_mult_without_std(Rest_part_vector_1, Rest_part_vector_2, SubResult), 
    Result is Elem_first_vector * Elem_second_vector + SubResult.
```

Сначала рассматриваем самый простой случай,когда оба списка-вектора пустые(получаем 0).Потом рекурсивно забираем первые элемента(головы) из этих списков и прибавляем произведение этих элементов в общий результат.(SubResult-это предыдущее значение результата).И так пока не дойдём до того момента,когда оба списка пусты.Если получается так,что один из векторов пустой,а другой нет,то тогда мы в этот пустой список-вектор добавляем 0 (это работает,что с первым вектором,что со вторым).

Реализация со стандартными предикатами:
```prolog
add_zero_vector(List, N, Finished) :-
    length(List, Len),
    (Len =:= N -> Finished = List; 
        Len < N -> 
            append(List, [0], NewList),
            add_zero_vector(NewList, N, Finished);
        Finished = List).

scalar_mult(V1, V2, Result) :-
    length(V1, Len1),
    length(V2, Len2),
    MaxLen is max(Len1, Len2),
    add_zero_vector(V1, MaxLen, NewV1),
    add_zero_vector(V2, MaxLen, NewV2),
    scalar_mult_calculation(NewV1, NewV2, Result).


scalar_mult_calculation([], [], 0).
scalar_mult_calculation([Elem_first_vector|Rest_part_vector_1], [Elem_second_vector|Rest_part_vector_2], Result) :-
    scalar_mult_calculation(Rest_part_vector_1, Rest_part_vector_2, SubResult),
    Result is SubResult + Elem_first_vector * Elem_second_vector.
```

В предикате scalar_mult(V1, V2, Result) мы начинаем сравнивать длины векторов V1 и V2, выбирая максимальную из них. Далее для обоих векторов мы запускаем предикат add_zero_vector(List, N, Finished), который позволяет добавлять нули к векторам по одному до тех пор, пока их длины не станут равными. Это происходит рекурсивно до тех пор, пока вектора не будут одинаковой длины. Мы запускаем этот предикат для обоих векторов, поскольку неизвестно, какой из них короче (длинный вектор не изменится, так же как и равные по длине).

После выполнения выравнивания длин векторов, мы переходим к предикату scalar_mult_calculation, в котором производится вычисление скалярного произведения обработанных векторов, точно так же, как и без использования стандартных предикатов.

## Задание 2: Реляционное представление данных

##### Реляционное представление данных:

Преимущества:
+ доступная расширяемость(делаешь новую таблицу и связываешь её со старой при этом старая таблица не сильно изменяется)
+ удобная структура и простой доступ к элементам(всегда есть пара <ключ>-<значение> в котором просто искать данные)
+ простота чтения и интуитивная понятность

Недостатки:

- Сложность запросов(при большом объёме информации становится трудно писать простые запросы и следовательно теряется читаемость и удобство реляционных баз данных)
- Использование памяти(реляционные базы данных могут использовать большое количество памяти для хранения связей между таблицами, особенно при больших объемах данных.)

##### представление данных,которое я использовал:
(four.pl)

Преимущества:
+ компактность информациии
+ использование списков(использование возможностей языка Prolog)

Недостатки:

- вложенность предикатов(сначала предикат subject,потом в списке предикат grade).Следовательно читаемоть ухудшается

Реализация four.pl. Вариант 1.
`student(Group,Surname) :- group(Group,ListGroup), member(Surname,ListGroup).` - предикат,который ищет студента в заданной группе.Из заданного факта берёт список студентов группы и с помощью стандартного предиката member ищет студента.
`ball(Surname,C) :- subject(_,ListGrades), member(grade(Surname,C),ListGrades).`-предикат,который ищет оценки студента. Он просматривает список оценок, связанный с каждым предметом (через предикат subject). Если находит оценку студента Surname с оценкой C в этом списке, он возвращает эту оценку C для указанного студента Surname.
Предикаты `solve_task1`,`solve_task2`,`solve_task3` запускают решение подзаданий для варианта 1.
Пример использования:
```prolog
?- solve_task1.
Группа  | Средний балл
---------------------------
  102   |  3.9444444444444446
---------------------------
  101   |  3.966666666666667
---------------------------
  104   |  3.861111111111111
---------------------------
  103   |  4.145833333333333
false.

?- solve_task2.
         Предмет        |     не сдали студенты
---------------------------------------------------
 Логическое программирование |  [Петровский,Сидоров,Джаво]
---------------------------------------------------
 Математический анализ |  [Петров]
---------------------------------------------------
 Функциональное программирование |  []
---------------------------------------------------
 Информатика |  [Сиплюсплюсов,Криптовалютников]
---------------------------------------------------
 Английский язык |  [Решетников,Азурин]
---------------------------------------------------
 Психология |  [Безумников,Круглосчиталкин]
false.

?- solve_task3.
Группа  | Не сдалo студентов
------------------------
 102    |   3
------------------------
 101    |   3
------------------------
 104    |   2
------------------------
 103    |   2
false.
```
Реализация первого подзадания:
```prolog
sum_list([], 0).
sum_list([Head|Tail], Sum) :-
    sum_list(Tail, TailSum),
    Sum is Head + TailSum.
ball_of_student(Group,C) :- student(Group,Surname), ball(Surname,C).
avarage_ball(Group,Res) :- findall(Res, ball_of_student(Group,Res), List_Result), sum_list(List_Result,Sum), length(List_Result, Length),  Res is Sum/Length.
solve_task1:-write("Группа  | Средний балл\n"),
    findall([Group, Avarage_ball], (group(Group, _), avarage_ball(Group, Avarage_ball)), GroupBall),
    print_group_ball(GroupBall).

print_group_ball([[Group, Avarage_ball] | Rest]) :-
    write("---------------------------\n"),
    write("  "),write(Group), write("   |  "), write(Avarage_ball), write("\n"),
    print_group_ball(Rest).
```
`sum_list([Head|Tail], Sum).`-предикат,который считает сумму списка.Рекурсивно проходимся по элементам списка и прибавляем элементы к результату.
`ball_of_student(Group,C).`-ищет оценки студентов в определенной группе. Нааходит всех студентов из группы ,а затем находит оценки  для каждого студента.
`avarage_ball`-находит средний бал всей группы.Суммирует все оценки группы и делит на их количество.
`print_group_ball`-выводит результат группы.

Реализация второго подзадания:
```prolog
subject_not_passed(S, Surname) :-
    subject(S, ListGrades),
    member(grade(Surname, 2), ListGrades).

not_passed_subjects :-
    findall([S, Res], (
        subject(S, _),
        findall(Surname, subject_not_passed(S, Surname), Res)
    ), Subjects),
    print_not_passed_subjects(Subjects).

print_not_passed_subjects([[S, Res] | Rest]) :-
    write("---------------------------------------------------\n"),
    write(" "), write(S), write(" |  "), write(Res), write("\n"),
    print_not_passed_subjects(Rest).

solve_task2 :-
    write("         Предмет        |     не сдали студенты\n"),
    not_passed_subjects.

```
`subject_not_passed(S, Surname).`-предикат,который ищет студентов,которые не сдали предмет S.Сначала берёт список оценок и проверяет есть ли у студента оценка 2 за этот предмет.
`not_passed_subjects.`-ищет всех студентов ,которые не сдали предмет. Проходится по каждом предменту и записывает студентов со всех групп,которые его не сдали 
`print_not_passed_subjects.`-печатает фамилиии студентов,которые не сдали предмет.

Реализация второго подзадания:
```prolog
student_not_passed(Group, Surname) :-
    student(Group, Surname),
    ball(Surname, 2).

not_passed_in_groups :-
    findall([Group, Length], (
        group(Group, _),
        findall(Surname, student_not_passed(Group, Surname), Result_List),
        length(Result_List, Length)
    ), GroupsResults),
    print_not_passed_in_groups(GroupsResults).

print_not_passed_in_groups([[Group, Length] | Rest]) :-
    write("------------------------\n"),
    write(" "), write(Group), write("    |   "), write(Length), write("\n"),
    print_not_passed_in_groups(Rest).

solve_task3 :-
    write("Группа  | Не сдалo студентов\n"),
    not_passed_in_groups.
```
`student_not_passed.`-предикат,который проверяет сдал студент сессию или нет.Ищет студента в группе и проверяет есть ли у него 2 за любой из предметов.
`not_passed_in_groups.`-находит всех студентов из каждой группы кто не сдал хотя бы один предмет.Для каждой группы проверяем сдал студент предмет или нет,если не сдал добавляем в список результатов.
`print_not_passed_in_groups`-печатает количество студентов из группы,которые попали на пересдачу.Смотрит длину Списка несдавших из группы
## Выводы

В ходе лабораторной работы я познакомился с Prolog, языком логического программирования, который предлагает отличный подход к решению задач. Одно из ключевых различий заключается в отсутствии операций "присвоения", характерных для императивных языков программирования. Prolog использует унификацию вместо этого. Работа в Prolog предполагает не процедурный, а декларативный подход, что позволяет рассматривать задачу с иной точки зрения и открывает новые перспективы для решений.

Изучение работы с Prolog также познакомила меня со списками. Рекурсивная структура списков дала понимание работы с рекурсией. Я освоил создание собственных предикатов для взаимодействия со списками и использование стандартных методов.

Кроме того, я начал осваивать работу с реляционными базами данных, выявляя их преимущества и недостатки. Это позволило мне создавать свои собственные предикаты для поиска информации в данных.

Лабораторная работа заставили меня задуматься о том, что необходимо изучать различные подходы к решению задач, искать наиболее выгодные и правильные решения для конкретного контекста. Развитие навыков в Prolog открыло новые горизонты в программировании и помогло взглянуть на задачи с разных сторон.